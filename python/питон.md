# Варианты исполнения кода на python

1. Интерактивный вариант (консоль Python/Shell)
IDLE - и есть интерактивый вариант. В нем каждая инструкция исполняется моментально 

2. Файловый вариант (стандартный вариант)

# Знакомство с объектами в python

Программа - это набор инструкций, которая описывает компьютеру определенную последовательность действий. 

Программа состоит из инструкций. В свою очередь каждая инструкция создает или обрабатывает объекты. 

Встроенные типы объектов Python

![типы объектов](img/Типы объектов)

Функция type() позволяет узнать тип объекта

## Числа и операции над ними

### integer

Целое число - число, не содержащее дробной части.

Целые числа - все отрицательные числа, положительные и ноль. 

Функция для преобразования в тип integer - int()

### float

вещественные числа (числа с плавающей точкой) отличаются от целых наличием *дробной части*

Пример: 7.6, 8.0, -5.5

Целая часть отделяется от дробной знаком "точки". 

Функция float() - преобразует данные в вещественный тип. 

### Основные операции

![операции](img/операции)

Тонкости в операциях: 
- 2%7 = 2 (7\*0+2(!))
- любые операции с вещественным числом возвращают вещественное число 

![приоритеты](img/приоретиты)

Некоторые встроенные функции по работе с числами: 
![встроенне операции](img/встроенные)

abs - модуль. функция, которая отбрасывает знак
pow - возводит первое значение в степень второго
round - округление до целого числа ( round(число, до какого разряда)), можно задавать отриц значения, тем самым, например, округлив по десятки. при этом 3.5 -> 4

![разряды](img/разряды)

Все математические функции находятся в модуле math.

# Переменные в питоне. Оператор присваивания. 

Переменная - именованная область памяти, предназначенная для хранения значения. 
= - оператор присваивания. 

Чтобы создать переменную, нужно положить в нее значение. То есть они создаются в момент первого их присваения. 

![переменная](img/переменная)

Переменная должна начинаться с буквы или нижнего подчеркивания. Питон чувствителен к регистру букв. Также переменные не могут иметь зарезервированное слово в качестве идентификатора. 

Имена функций можно использовать в качестве идентификаторов, но возможность вызова этих функция потеряется. 

Создание переменной: 
а = 4
Есть список переменных и список объектов. 

- Создается объект целого типа со значением 4 
- Затем проверится есть ли переменная а. если нет, то она создается. 
- в переменной а сохранится ссылка на объект. 
Если мы присвоим переменной новое значение то:
- создастся объект вещественного типа со значением 5.4 
- Переменная а уже существует
- В переменную а сохранится новая ссылка, при том старая пропадет.

Динамическая типизация - переменные могут принимать значения любых типов. 

![присваивание](img/присваивание)

Массовое присваение: a=b=c=1
Множественные присваения: a, b = 2, 7 

# Ввод и вывод данных в питоне. 

Функция input() - считывает значения, которые пользователь вводит в консоль и возвращает его. 

Функция print() - выводит переданные ей значения. 

У нее есть параметр - sep (separate-разделять, separator - разделитеть). По умолчанию он равен пробелу. Чтобы изменить это поведение, нужно последним аргументом указать значение sep='' на произвольную строку, которая будет в качестве разделителя.

Также есть параметр end, который отвечает за то, что будет выводиться после всех значений, в конце. end='\n' - по умолчанию. Передав end новую строку, можно изменить его поведение. 

%s - специальный параметр, который указывается в строке, чтобы подставить туда значения из переменных. 
![процент](img/процент)

# Деление нацело и остаток от деления

Если любое число %10 - получим последнюю цифру

**любое число % (10 \*\* n) ** где n - сколько цифр хотим взят с конца. 

Если любое число //10 - уберем последнюю цифру 

**любое число // (10 \*\* n))** - где n - сколько цифр с конца нужно убрать 

# Функции trunc, floor, ceil

Все эти функции находятся в модуле math. 
trunc() - отсекает дробную часть. 
int() - тоже в процессе прообразования отсекает дробную часть. 
floor() - округление вниз. Наибольшее целое число, которое не превосходит нашего вещественного числа. 
ceil() - округление вверх. Наименьшее целое число, которое превосходит наше вещественное число. 
ceil() и floor() возвращают целые числа. 

# Логический тип bool. Операторы сравнения и is 

![сравнение](img/сравнение)

x%2==0 : True - четное, False - нечетное

x%n==0 : кратность, где x - число, которое кратно n. True - кратно, False - нет. 
x%n!=0 : некратность n. так же можно записать с помощью not x%4==0 

**and, or, not** 

bool() - функция преобразования в bool (любое непустое значение преобразуется в True)

- оператор == проверяет равенство значений двух объектов
- оператор is проверяет идентичность самих объектов. Его используют, чтобы удостовериться, что переменные указывают на один и тот же объект в памяти

Python (CPython, если быть точнее) в целях производительности кеширует короткие строки и малые целые числа, поэтому возможны такие казусы:

```python
str1 = 'hello'
str2 = 'hello'
str1 == str2 # True
str1 is str2 # True

str1 = 'hello, my crazy world'
str2 = 'hello, my crazy world'
str1 == str2 # True
str1 is str2 # False

```

# Строки и операции над ними

строки - ' ' или " "'
Многострочные строки - ''' ''' 

\n - перенос строки 
\t - табуляция 

'string' + 'second_string' - 'stringsecond_string' (конкатенация строк)
"a" * 5 - 'aaaaa' (умножение строк)

str() - преобразование в тип str

len() - длина строки, возвращает тип int 

с помощью **in** можно проверить есть ли какая то подстрока в нашей строке. 

Питон сравнивает строки посимвольно по коду букв. 'r'>'abc'
Числовое значение буквы можно получить с помощью функции ord().
Эти коды можно загуглить - ascii code table 

# None

None - неопределено

## Индексы и срезы 

Строка - **упорядоченная** коллекция символов. 
То есть каждый символ имеет свой индекс. 

Чтобы обратиться к каким либо символам строки через индекс, нужно указать его в []. 
строка[номер индекса]
'Hello'[1] -> e

string[len(string)-1] - чтобы получить последнюю букву. ИЛИ string[-1]

Срез - строка[С какого индекса брать:ДО какого брать]
В срезе можно не указывать один из индексов (правый или левый): 
string[4:] - с 4 до конца
string[:6] - с начала ДО 6
string[:] - вся строка 
Чтобы указать шаг нужно: string[::шаг]

Строка *неизменяемый* объект - то есть присвоить значение по индексу не получится. 
Но можно создать новую строку с помощью срезов и конкатенации. 

## Методы строк 

Метод - функция, которая связана с определенным типом объекта. То есть методы являются специфичными для каждого отдельного типа. 

Вызов метода: объект.метод(аргументы)

**Также есть цепочки вызовов методов: ** объект.метод().метод().метод()

s.upper() - метод, который ВОЗВРАЩАЕТ строку, где все ее буквы заглавные
s.lower() - метод, который ВОЗВРАЩАЕТ строку, где все ее буквы строчные

s = s.upper() - чтобы сохранить изменения

s.count('str', [начальный индекс, [конечный индекс]]) - подсчитывает сколько раз встретилась подстрока 'str' в строке s

s.find('str', [начальный индекс, [конечный индекс]]) - ищет индекс подстроки 'str'
s.rfind('str') - ищет индекс подстроки 'str' с конца

s.index('str') - возвращает индекс указанной подстроки
s.replace('o', '', количество замен) -  заменяет подстроку на другую (можно убрать пробелы в строке или удалить некоторые буквы)
s.isalpha() - возвращает True, если строка состоит целиком из букв
s.isdigit() - возвращает True, если строка состоит целиком из цифр
s.rjust(n, 'ОДИН символ заполнителя') - строка "прижимается" к правому краю и следовательно ПЕРЕД ним добавляется некоторое количество знаков заполнителя до того момента, когда длина строки будет равна n.  
s.ljust()

s.split('разделитель') - Разбивает строку по пробелам (по разделителям) и добавляет подстроки в список. 
![сплит](img/сплит)
связующий знак(разделитель).join(список строк)
![джоин](img/джоин )

s.strip() - удаляет знаки пробелов и служебные знаки(переносы строк)
s.rstrip() - удаляет справа знаки пробелов и служебные знаки(переносы строк)
s.lstrip() - удаляет слева знаки пробелов и служебные знаки(переносы строк)

# Форматирование строк

## метод format

Позиционное форматирование строк: 
print('text {0} text text {1} text text text {2}').format(value1, value2, value3) 
переменные в аргументе метода format нумеруются от 0 до n. Эти номера подставляются в строку в фигурных скобках. 

Именованное форматирование строк: 
a, b, c = 1, 2, 3
print('text {value1} text text {value2} text text text {value3}').format(value1=a, value2=b, value3=c) 

## f-строки

a, b = 1, 2
print(f'text {a.lower()} text text {b\*2} text {abs(-45)} text') - нужно поставить перед форматируемой строкой букву f и заключить названия переменных или инструкции в строке в фигурные скобки. 

# Списки и операции над ними

Список - упорядоченная коллекция элементов. Они позволяют хранить взаимосвязанные данные. 

[элемент, элемент, элемент] - список
Элементы могут быть любых типов.

len() - возвращает количество элементов в коллекции.

Сцепление списков: 
[a, b] + [c ,d] = [a, b, c, d]

Добваить элемент в конец: 
список = список + другой список

Добавить элемент в конец: 
список = другой список + список

Дублирование списков: 
[1, 2, 3] * 2 = [1, 2, 3, 1, 2, 3]

a = 'Hello'
list(a) -> ['H', 'e', 'l', 'l', 'o']

Проверка вхождения: 
значение in список -> True или False 

Если список состоит целиком из чисел, то вы можете:
max()
min()
sum()

sorted(список) - возвращает отсортированный список по возрастанию (по умолчанию)
Параметры: reverse=True - по убыванию 

Сравнение списков: 
Списки сравниваются поэлементно, то есть [3] > [2, 3, 1] -> True
список == список -> True , если в списке одинаковое количестко идентичных элементов. 

Среднее арифметическое списка: 
sum(список)/len(список)

**Распокование переменных **
a = [1, 2, 3]
b, c, d = a -> b = 1, c = 2, d = 3

## Списки: индексы и срезы

список[номер индексы] - обращение к элементу

Индексы от 0 до n, либо от -1 с конца до -n

Срез: список[ОТ какого индекса, ДО какого индекса]
При срезах можно указывать те значения индексов (напрмер очень большие), которых на самом деле нет. 

список[:до какого]
список[с какого:]
список[:]
список[n:n:g] , где g - шаг 

a = [ 1, 2, 3, 4, 5]
print(a[2:999:2])
-> [3, 5]
то есть первый элемент вне зависимости от шага - берется

список[::-1] - перевернуть список задом наперед. 

Список - **изменяемый объект** (в отличии от строк), поэтому по индексу можно поместить туда новое значение.

список[0, 2] = значение, значение - можно менять значения с помощью срезов. 
список[0, 3] = значение, значение

![прога](img/прогасписки)
![результат](img/спискирезультат)

Если с помощью среза, назначить как минимум трем элементам два значения, то те элементы, которым не хватило значений - удалятся ( в нашем случае третий).
То есть нескольким элементам, можно назначить только ОТ двух значений. 

С помощью функции del можно удалять значения по индексам. 
del список 
del список[i] 
del список[i:j:k] 

**Важная особенность списков:**
Если a = [1, 2, 3], а b = a, то переменные (которые хранят ссылки на объекты) будут ссылаться на один и тот же объект (**только в случае со списками**), и поэтому при изменении списка в одной переменной, мы изменяем этот же список и в другой. 
Чтобы избежать этой ситуации делать так:
a [1, 2, 3]
b = a[:]
тогда, мы сохраним в переменной b *копию* объекта, и списки в обоих переменных будут меняться независимо друг от друга. 

## Списки и их методы 

Методы в строках лишь *возвращают измененную строку*, но не меняют ее. В списках же дела обстоят иначе, методы меняют список. 

 append() добавляет *один* элемент с указанным значением в конец списка. 

Никогда не использовать методы, такие как append, с присвоением этой же переменной (как это было в строках): 
a = a.append(n)
иначе, потеряются все значения, будет None. 

 clear() - он очищает список.

 copy() - делает копию списка. (эквивалент список[:]) :
b = a.copy()

 count(значение) - подсчитывает сколько раз встечается определенное значение в списке.

 index(значение, начальный индекс, до какого индекса) - будет проходить по списку и искать индекс этого первого найденного значения. 

insert(индекс, объекст) - вставляет объект в нужное место, а все остальные значения сдвигаются вправо. 

pop() - удаляет значение с конца и возвращает его. 
pop(индекс) - удаляет и возвращает значение по индексу. 

remove(значение) - ищет значение в списке и удаляет одно лишь первое. (выводит исключение, если ничего не находит)
Для удаления всех значений лучше воспользоваться циклом while. 

reverse() - переворачивает список (эквивалент список[::-1])

sort() - сортировка по возрастанию
sort( reverse=True) - по убыванию 
sort(key=function)
эта функция отвечает за то, по какому критерию будет происходить сортировка. По сути сортировка будет происходить по возвращаемому значению, например:
```python
def f(x):
	return x%10
a = [14, 123, 4, 74, 97, 34, 68, 21, 39]
a.sort(key=f) # список будет отсортирован по последней цифре
```

**Функция sorted()** - встроенная, она сортирует любую коллекцию, возвращая список. 

## Вложенные списки

список = [[элемент, элемент], [элемент, элемент], [элемент, элемент]]
список\[индекс вложенного списка][индекс элемента во вложенном списке]

# Условный оператор if

if условие: 
	инструкции
else: 
	инструкции
инструкции

Для составных проверок - and, or, not
Отступ для отделения блоков - 4 пробела. 

Вложенность операторов if: 

if условие: 
	if условие:
		инструкции
	else:
		инструкции
else: 
	инструкции 

Множественный оператор if: 
if условие: 
	инструкции
elif условие:
	инструкции
...
else: 
	инструкции

# Цикл while

Конструкция while:
while условие:
	инструкции в цикле
	...
инструкции вне цикла

Пока *условие* будет верным, инструкции в теле цикла будут выполняться.

Инструкция **break** совершает принудительный выход из цикла. (и обходит блок else)

Инструкция **continue** принудительно завершает  итерацию и заново проверяет условие (перекидывает в начало цикла).  

Инструкция **else**: блок else будет выполняться после всех итерация цикла и только в том случае, когда цикл завершился "сам по себе" (без принудительного выхода).

while условие: 
	инструкции
else: 
	инструкции

# Функция range и итерируемые объекты

range() - помогает сформировать конечную арифметическую прогрессию. 
range - неизменяемый объект. 

range(До какого числа сформировать прогрессию)
range(С какого числа, ДО какого числа)  
range(С какого числа, ДО какого числа, шаг)

старт по умолчанию равен нулю, а шаг 1.

Функция range является итерируемым объектом. 
**Итерируемый объект** это объект, предоставляющий возможность поочередного прохода по своим элементам. 

Если функция range присвоена переменной, то по ней можно обращаться к значениям последовательности по индексам. Индексация начинается с нуля. (все это из за того, что это итерируемый объект)

range формирует пустую последовательность, если передать ей один аргумент - 0, или указать неправильный интервал.

Чтобы увидеть последовательность можно сформировать список из нее с помощью функции list().

Функция iter(итерируемый объект) - создает итератор.
С помощью функции next(итерируемый объект) можно вытаскивать из объекта следующие элементы. Итератор будет сам запоминать, где ( на каком индексе) он остановился. Если вызвать next при том, что элементы закончились, то он выдаст исключение. 
\# next() - функция
\# итерируемый\_объект.\_\_next\_\_() - метод

Цикл for сам вызывает этот метод next() и присваивает значение итерационной переменной. Так же он не выдает исключения, когда переменные закончились. 

# Цикл for

Цикл for в программировании - цикл с известным количеством повторений. 
Но в питоне это наиболее универскальный инструмент, с помощью которого так же можно поочередно обойти все элементы итерируемого объекта. 

for итерационная\_переменная in итерируемый объект : 
	тело цикла

Цикл for поочередно присваивает итерационной переменной все значения итерируемого объекта. 

Самые частые итерируемые объекты - range, строка, список и другие массивы. 

обход списков и строк: 
- по значениям for i in список/строка: 
- по индексам for i in range(len(список/строка))
Последний является более универсальным. 

Вложенные циклы. 
Формат: 
for переменная in объект:
	for переменная in объект:
		инструкции
		while условие: 
			инструкции
	инструкции 

# Множества, тип данных set 

Множество - неупорядоченная коллекция уникальных элементов. (отсутствуют повторяющиеся значения и индексы)

a = {  элемент, элемент, элемент }

a = { 1, 2, 3, 1, 2, 3} - > {1, 2, 3}

set() - преобразует объект в множество (исключает "дубли")
set('abcac') -> {'b', 'a', 'c'} (неупорядоченная коллекция!)

Чтобы создать пустое множество нужно использовать функцию set(). Выглдеть оно будет так    ' set() '. Нельзя создать пустое множество просто поставив {}, ибо в таком случае объект будет являться словарем. 

**Множество может содержать только НЕизменяемые объекты**
( числа, строки, кортежи )

list(set(список)) - убрать все дубли из списка

множество.add(значение) - изменяет сам объект, а не только возвращает его.

ЗАПРЕЩЕНО: a = a.add(элемент). Иначе, как и со списками, потеряем все значения

множество.update(итерируемый объект) - добавляет элементы итерируемого объекта (кроме изменяемых) в множество. 

Множество - **итерируемый объект**, но добавлять его нельзя

**Множество - изменяемый объект, поэтому он работает в плане присвоения одного и того же множества двум переменным и изменении одного из них - так же, как и списки со словарями (изменяемые объекты)**

множество.discard(значение) - удаляет элемент из множества, не выдает исключение, если элемента уже нет во множестве. 
множество.remove(значение) - удаляет элемент из множества, но будет исключение, если элемента не оказалось во множестве. 
множество.pop() - удаляет и возвращает случайный элемент. Если множество пусное, то будет ошибка
множество.clear() - очищает все элементы множества. То есть делает его пустым. 

## Операции над множествами

**Результаты операций над множествами МОЖНО присваивать этим же множествам**

len(множество) - длина

элемент in множество 

множество & множество2 - пересечение -> множество-пересечение

Чтобы присвоить результат пересечения множеств одному из множестве:
a &= c

множество1.intersection(множество2) - возвращает пересечение
множество1.intersection\_update(множество2) - присваивает множество пересечение в множество1. (не присваивать результат переменным)

множество1 | множество2 - объединение множеств
множество1.union(множество2) - тоже объединение
множество1 = множество1.union(множество2)

множество1 - множество2 - вычитание множеств

множество1 ^ множество2 - симметричная разность

Множества можно *сравнивать*: 
множество1 == множество2 - принадлежат ли все элементы одного мн-ва другому мн-ву и наоборот.

множество1 < множество2 - будет ли являться множество1 подмножеством множества2.
также >, >=, <= (подмножество или равно)

# Словари - dict. Операции и методы словаря. 

Словать - неупорядоченная коллекция произвольных объектов с доступом по ключу. (Ассоциативный массив)

словарь = { 
	ключ : значение,
	ключ : значение,      - **используется часто**
	ключ : значение
}

словарь[ключ]

Чаще всего ключ - строка (или любой другой тип данных, кроме изменяемых типов объекта (список, словарь, множество ))
В словаре не может быть два одинаковых ключа. (Сохранится последний из них)
Значением может являться любой тип данных

dict(ключ=значение, ключ=значение) - создает словарь. При таком способе создания ключ обязательно должен быть строкой. 

Ключ можно писать без кавычек, функция сама сделает значения ключей строками.

Также словарь можно создать так: 
dict( [ [ключ, значение], [ключ, значение],[ключ, значение] ] )

словарь.fromkeys( ['a', 'b', 'c'] ) -> {''a" : None , ''b" : None, ''c" : None }
словарь.fromkeys( ['a', 'b', 'c'], значение по умолчанию) -> {''a" : значение , ''b" : значение, ''c" : значение }

переменная = {} - пустой словарь (**часто используется**)
переменная = dict() - пустой словарь

словарь {
	ключ : значение
	ключ : { ключ : значение, ключ : значение}
}

словарь\[ключ][ключ] 

словарь[новый\_ключ] = значение - **добавление новой ассоциации**
словарь[существующий\_ключ] = новое\_значение - **изменение значения ассоциации**

del словарь[ключ] - удаление ассоциации. (возвращает исключение, если такого ключа нет)

ключ (not) in словарь - проверка ключа

for key in словарь: 
	print(key, словар[key])
-> вывод ключа и значения (**цикл проходит словарь по ключам**)

**Словарь работает так же, как и список в случае присваение двум переменным ссылки на один и тот же словарь:**
```python
a = {1:'hi', 2:'world'}
b = a
b[1] = 'another'
# a, b == {1:'another', 2:'world'}
```

**Методы:** 

словарь**.** ...

.clear() - очищает словарь

.get(ключ) - возвращает значение ключа. Отличие: если передать несуществующий ключ, то метод вернет значение None. 
.get(ключ, объект) - возвращает вместо None этот объект.

.setdefault(ключ) - вернет значение ключа, или если его нет - создает его и присвоит значение None. 
.setdefault(ключ, значение) - если ключа нет, то создает его и присвоит это значение (любой объект) 

.pop(ключ) - вернет значение ключа и удалит эту ассоциацию в нем. Вернет исключение, если ключа нет.

.popitem() - удаляет случайную ассоциацию и возвращает ее в виде словаря. Выдаст ошибку при попытке удалить что то из пустого словаря. 

.keys() - возвращает объект типа dict keys -> dict_keys([ключ, ключ, ключ])
цикл for по сути обходит значения по объекту типа dict_keys 

.values() - возвращает объект типа dict values -> dict_values([значение, значение, значение])
С помощью этого метода в цикле for можно пройтись по значениям. 

.items() - возвращает коллекцию в которой содержаться все пары - dic items -> dict_items([(ключ, значение), (ключ, значение), (ключ, значение)])
С помощью цикла for также можно обойти ассоциации. 

**Функция sorted** - встроенная. сортируют любую коллекцию

for key, value in словарь.items():
	print(key, value)

Это работает по принципу множественного присвоение 
a, b = [4, 7] -> a= 4, b = 7

**Где используются словари**: 
- подсчет чего либо (ключ - объект, значение - количество)
- установление соответствия

# Метод подсчета. Сортировка подсчетом

Метод подсчета - реализация чего либо через подсчет объектов.

Сортировка подсчетом заключается в том, что мы, проходя по массиву, подсчитываем сколько раз они встречаются и записываем это в новый массив (массив подсчета). Количество элементов массива подсчета будет зависеть от того, каков диапазон значений в изначальном массиве. В массиве подсчета индексы будут являться числами из старого массива, а значения в них - то, сколько раз они встречаются в старом массиве.

![подсчет](img/подсчет)

Массивы выглядят так: 

![](img/подсчет3)

Чтобы создать массив с уже отсортированными числами можно пройтись по всем элементам массива подсчета и вставить в его начало **индексы** элементов столько раз, сколько указано в значении элемента.  

![подсчет2](img/подсчет2)

Сортировка списка с отриц числами происходит благодаря смещению индексов в массиве подсчета на n. Где n - модуль минимального отрицательного числа. (в данном случае n - 10)

![смещение](img/смещение)

# Кортежи

Кортеж (tuple) - неизменяемая последовательность, обычно используемая для хранения разнотипных объектов.  

кортеж = ( элемент, элемент, элемент)
кортеж = элемент, элемент, элемент
кортеж = tuple()  ==  кортеж = ()
кортеж = tuple(итерабильная последовательность )

Индексация элементов такая же, как у списков

Изменяемые объекты в кортеже мы вправе изменить. (вложенные в кортеж список например)

Кортежи используются: 
- если необходимо гарантировать неизменяемость объекта
- потому что занимают меньше места в памяти (  служебный метод - .\_\_sizeof\_\_()  - значение в байтах )
- кортежи, как ключи словаря ( списки нельзя так использовать) 
- Кортеж тоже последовательность
## Операции с кортежами

len(кортеж)
оператор (not) in 

Оператор сцепления - кортеж + кортеж - возвращает сцепленный кортеж (порядок операндов важен)

кортеж * 2 - дублирование

min(), max(), sum() - если в кортеже числа

**Срезы** такие же, как у списков.

del кортеж 

## Методы кортежей

.index(значение элемента) - возвращает индекс элемента или ошибку, если такого элемента нет 

.count(элемент) - возвращает число - сколько раз встречался этот элемент.

# Функции

## Определение и вызов

Функция - многократно используемый фрагмент программы. При помощи функций можно объеденить несколько инструкций в один блок, присвоить этому блоку имя и затем, обращаясь по имени этого блока, выполнить инструкции внутри него в любом месте программы необходимое число раз.

def (definition) - ключевое слово для объявления функция 

Определение функции:

def имя блока/функции(): 
	инструкции

 имя функции() - вызов функции

 За счет () происходит обращение к функции. Без них функция ни выполнится. 

 def функция(имя аргумента): 
 	инструкции с аргументом

 Аргументы - позиционные поэтому при def функция(аргумент1, аргумент2) в вызове нужно передавать аргументы так же, как в определении функции.

if условие: 
	def функция():
		инструкции
else: 
	def функция():
		другие инструкции

Если два раза определить одну и ту же функцию, то функция будет перезаписана и сохранится второй вариант. 

Чтобы оставить функция пустой нужно в теле написать инструкцию pass
def abc():
	pass

## Зачем нужны функции

1. Устраняют избыточность кода
2. Обеспечивают декомпозицию проблемы - возможность разбить одну большую задачу на более мелкие задачи. 

## Возвращаемое значение функции. Оператор return

Возвращаемое значение - это значение, которое 'подставляется' на место вызова функции. 

Любая функция в питоне возвращает какое либо значение при помощи оператора return, но если этого оператора нет, то она вернет None

a = функция() - при объявлении переменной, хранящей в себе функцию, функция, кнчн же, сначала выполнится, а потом запишется в переменную. Даже print, которая выведет что либо на экран, а потом вернет None. 

оператор - return значение - возвращает значение и выходит из функции ( как break из цикла)

Вернуть можно любой тип данных

return значение, значение -> ( значение, значение) - кортеж

## Области видимости. Встроенная, глобальная и локальная области видимости. 

Чтобы создать переменную нужно присвоить ей значение. Но от того, **где** будет присвоено это значение будет зависеть то, к какой области видимости будет относится данная переменная. 

Область видимости - место, где было присвоено значение переменной, и где осуществляется поиск по этому имени. Она определяет контекст переменной, в рамках которого ее можно использовать. 

Области видимости:
**Локальная** область видимости создается внутри функции. 
def s():
	#local
	a, b, c = 1, 2, 3    - будут видны только в функции s()

Локальные переменные существуют только в момент работы функции. После того, как функция отработает, переменные удаляются.

Внутри функции невозможно обращаться к локальным переменным другой функции. 

**Глобальная область видимости** - это любые переменные, которые создаются вне функций. Глобальная переменная доступна в любом месте текущего модуля (программе/файле) 

К глобальным переменным можно обращаться внутри функции, но менять их нельзя. Если попробовать "изменить" глобальную переменную, то просто создастся локальная переменная с таким же именем.

Функция id() - возвращает идентификатор переменной

def s():
	print(w)
	w = 'hi'
w = 'hello'
s()
-> ошибка. Потому что несмотря на то, что переменная w уже существовала в глобальной области видимости, питон пробегает по содержимому функции и понимает, что в ней есть локальная переменная с таким же именем и не дает использовать имя этой переменной до ее объявления.

**По месту присвоения переменной питон понимает к какой области она относится.**

def функция(параметр, параметр):
	инструкции			# эти параметры автоматически становятся локальными переменными.

\Глобальные **изменяемые** объекты (такие как списки, словари, множества) могут подлежать изменению в функиях. Чтобы избежать такой ситуации со списками, нужно передавать полный срез списка.

Инструкция **global** позволяет изменить значение глобальной переменной в функции.
def ...:
	global глобальная переменная
	изменяем глобальную переменную

Всё вышеперечисленное работает также и с **функциями**, ибо у функций тоже есть имена. Первый уровень функция доступен в глобальной области видимости.

**Встроенная область видимости.**
В эту область видимости входят все встроенные функции, объекты и переменные. Чтобы ее увидеть в пайчерме нужно нажать ctrl + пробел. ( на против встроенных функций и ключевых слов будет стоять слово builtins)

Имена из встроенной области видимости, за исключением ключевых слов, можно переопределить. При чем как в глобальной, так и в локальной области видимости.

print(abs(-7)) -> 7
def w(a):            
	return a**2    / или сразу def abs:
abs = w             
print(abs(-7)) -> 49 

![](img/вложенныефункции)

-> 
hello q
200 s

**Правило поиска имен** в питоне.

Существуют:
- встроенное пространство имен
- глобальная область видимости
- локальная область видимости (объемлющие и локальные)

![](img/пространства)

Порядок поиска имени: 
1. Локальная область видимости
2. Объемлющая
3. Глобальная
4. Встроенная

![](img/объемлющая)

->
hello
hello

Чтобы из локальной функции изменить значение переменной в объемлющей функции необходимо использовать конструкцию nonlocal. То есть в локальной функции мы говорим, что берем нелокальное значение какой либо переменной. А следовательно берем из объемлющей. Инструкция nonlocal используется только во вложенных функциях и не работает с глобальной областью видимости.

## Передача аргументов 

Передача аргументов - передача объектов внутрь функции во время ее вызова.

При добавлении в функцию параметров "def функция(параметр, параметр):" в ней автоматически создаются локальные переменные с именами параметров.

*В момент передачи аргументов в вызываемую функцию автоматически происходит присваение значений из аргументов локальным переменным из параметров функции.*

Если в аргумент функции передается глобальный объект, то в ней будет локальная переменная, которая ссылается на тот же самый объект, что и хранящая его глобальная переменная: 
![ссылки на объекты](img/ссылкиаргументы)

**Позиционная передача аргументов**:
def функция(параметр1, параметр2, параметр3):
	инструкции
функция(аргумент1, аргумент2, аргумент3)

Все параметры в этом случае являются обязательными (ни больше, ни меньше).

**Передача аргументов по имени**:
def функция(параметр1, параметр2, параметр3):
	инструкции
функция( параметр2=аргумент2, параметр1=аргумент1, параметр3=аргумент3)

При таком варианте передачи нужно строгу соблюдать имена параметров. Порядок передачи аргументов не важен.

**Комбинированный вариант**: 
```псевдокод
def функция(параметр1, параметр2, параметр3):
	инструкции
функция(аргумент1, параметр3=аргумент3, параметр2=аргумент2)
```

В таком варианте можно некоторые аргументы передавать позиционно, а другие по именам. 
Сперва нужно указывать позиционные аргументы, строго соблюдая их порядок в параметрах, а только после них по именам, где порядок оставшихся аргументов не важен.

При объявлении функции некоторым параметрам можно присвоить **значения по умолчанию** и тем самым сделать их необязательными: 
```псевдокод
def функция(параметр1, параметр2, параметр3=значение по умолчанию):
	инструкции
функция(аргумент1, аргумент2) 
функция(аргумент1, аргумент2, аргумент3)
```
Значение по умолчанию в скобках должны отделяться от обяхательных и быть во сторой части: *функция(параметр1, параметр2, параметр3=значение по умолчанию, параметр4=значение по умолчанию*). То есть обязательные параметры не могут стоять после параметров со значениями по умолчанию.

## Передача аргументов: \*args и \*\*kwargs

Оператор звездочка принимает в качестве операнда переменную или объект , в которую **запаковывает** лишние значения, или который **распоковывает** по переменным. Также он может принимать функцию
**\*объект/переменная/функция**
Группа лишних переменных возвращается в виде списка.

```python
*a, b, c = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
# a = [1, 2, 3, 4, 5, 6, 7, 8]; b =  9; c = 10.
```
При множественном присваивании оператор звездочка должен быть только один.

Так же оператор звездочка может защищать от нехватки значений при присваении.
```python
*a, b, c = [1, 2]
#В этом случае в переменной a будет пустой список. 
```

Также оператор \* может распоковывать значения **из** объектов в переменные.
```python
s = [4, 10]
print(list(range(*s))) # [4, 5, 6, 7, 8, 9]
```

```python
def f(a, b, c, d):
	print(a, b, c, d)
a = (1, 'hello', True, [3,7,8])
f(*a) 
#Здесь оператор звездочка распакует кортеж по аргументам
```

**Оператор звездочка при определении функции**
**args**
```python
def f(*args):
	print(args, type(args))
f(1, 2, 3, 4, 5) # (1,2,3,4,5) class 'tuple'
f() # () class 'tuple'
```

Если указать оператор звездочка в параметре функции, то все переданные при вызове аргументы упакуются в нее. То есть при помощи него в функцию можно передать n-ое количество неименованных аргументов.
```python
def f(a, *args, c):
	pass
f(1, 2, 2, 2, c=3) # после параметра args не может быть позиционных аргументов. После него можно передавать аргументы только лишь по имени. 
```

Обычно для такого параметра используют имя *args*

**kwargs**
При помощи оператора \*\*kwargs можно передавать в функцию аргументы по имени в неопределенном количестве:

```python
def f(**kwargs):
	pass
f(a=1, b=4, c=6)
#При чем локальная переменная kwargs примет значение в виде словаря: 
#{'a':1, 'b':4, 'c':6}
```

**Комбинирование args и kwargs**

```python
def f(*args, **kwargs):
	pass
```
При этом сначала нужно будет указывать позиционные аргументы args, а затем kwargs

*Фишка*
```python
a = [1, 2, 3]
print(a) # [1,2,3]
print(*a) # 1 2 3
```

## Изменяемые объекты в качестве значений по умолчанию в функции

*Не использовать изменяемые объекты в качестве объектов по умолчанию:*
```python 
def append_to_list(value, my_list=[]):
	my_list.append(value)
	print(my_list)
append_to_list(77) # [77]
append_to_list(99) # [77, 99]
append_to_list(111) # [77, 99, 111] - все это несмотря на значение по умолчанию

# А чтобы сделать так, чтобы значения добавлялись в новый пустой список, нужно написать: 

def append_to_list(value, my_list=None):
	if my_list is None:
		my_list = []
	my_list.append(value)
	print(my_list)
```

**Так же работает со словарем**

# Рекурсия в питоне

Рекурсия в программировании - вызов функции самой себя.

У рекурсии должен быть выход - какое то условие, при выполнении которого функция переставала бы вызывать себя.

Чтобы воспользоваться рекурсией для решения задачи нужно:
1. Задача должна иметь такой набор данных, для которого есть простое решение - выход из рекурсии. (как например 1! = 1)
2. Задача должна иметь возможность сводиться к более мелкой - подзадаче.

# Функция enumerate

Функция enumerate принимает коллекцию и возвращает итерируемый объект типа enumerate. 
```python
a = [10, 20, 30, 40]
print(list(enumerate(a))) #[(0,10), (1,20), (2,30), (3,40)]
```
Вывод: функция enumerate генерирует последовательность элементов в виде кортежей, в которых на первом месте стоит число от 0 до n, а на втором элемент изначальной коллекции.

Очевидно, что объект типа enumerate можно обходить в цикле for. 

for кортеж in enumerate(итерируемая последовательность):
	pass

for индекс, значение in enumerate(итерируемая последовательность):
	pass

*enumerate(коллекция, начальное значение нумерации)* 

```python
print(list(enumerate(['a','b', 'c'],10))) #[ (10,'a'), (11,'b'), (12, 'c') ]
```

# Lambda фукнции

lambda функции - функции не имеющие имени, анонимные функции

Для создания такой функции есть ключевое слово *lambda* 

**Синтаксис**:
lambda аргументы : возвращаемое выражение

```python
r = lambda x: x**2
print(r(7)) #49
```

Так как у анонимной функции нет имени, по которому можно было бы к ней обращаться, то нам нужно например присовить эту функцию переменной.

lambda используется тогда, когда есть необходимость в функции, которая выполняет лишь одно действие/инструкцию.

Пример
```python
a = lambda : 'hello' #функция не принимающая никаких аргументов
```

В lambda не может быть циклов.
Но могут быть условные операторы:
```python
def f(x):
	if x>0:
		return 'positive'
	else:
		return 'negative'

t = lambda x: 'positive' if x > 0 else 'negative' # идентичные функции
```

Сортировка списка с помощью анонимной функции:
```python
a = [14, 123, 4, 74, 97, 34, 68, 21, 39]
a.sort(key=lambda x: x%10) # список будет отсортирован по последней цифре
```

Примеры использования:
```python
def linear(k,b):
	return lambda x: x*k+b
graf1 = linear(2,5)
print(graf1(3)) # y = x*2+5, где x = 3

f = lambda k, b: lambda x: k*x+b
graf1 = f(2,5)
print(graf1(3)) # то же самое только с лямбда
```
**Условный оператор в lambda** 
слова *elif* в лямбда нет, но можно использовать вложенный if  
```python 
d = lambda x: 'Hello' if x > 100 else ('world' if x > 0 else 'hi')
```

# Функция isinstance

Эта функция позволяет проверить к какому типу объектов относится значение.

```python
isinstance(значение, тип ) 

if isintance('hello', str): # Вернет True
	pass
	
if isintance(2.5, (int, float)): # Вернет True
	pass
```

# Генераторы списков

```python
# [выражение for i in коллекция]
a = [i**2 for i in range(5)]
```
Изменение списков с помощью генераторов:
```python
a = [1, 2, 3, 4, 5]
a = [elem+1 for elem in a]
```
Условия в генераторах списков:
```python
a = [i for i in range(10) if i%2==0]
# Нельзя писать:
# a = [i for i in range(10) if True else i**2 for i in range(10)]
```
Вложенные циклы в генераторах: 
```python
a = [(i,j) for i in 'abc' for j in [1,2,3]]
# Каждое значение сочетается с каждым
```

## Вложенные генераторы списков 

```python
# [[выражение for i in коллекция] for i in коллекция]    
```

# Генераторы и итераторы. Выражение-генераторы

**Генератор** - итератор, элементы которого можно итерировать только один раз.

```python
a = (выражение генератора)
```

**Итератор** - объект, который поддерживает функцию next(). Помнит о том, какой элемент будет браться следующим.

**Итерируемый объект** - объект, который предоставляет возможность обойти поочередно свои элементы. Может быть преобразован к итератору.

Функция iter(итерируемый объект) - преобразует итерируемый объект в итератор.

```python
s = [1,2,3] #итерируемый объект, который не поддерживает функцию next()
d = iter(s)
next(d) # 1
next(d) # 2
next (d) # 3
next(d) # ОШИБКА
```

*Генератор по умолчанию является итератором*
Как сделать генератор:

```python
b = (i**2 for i in range(1,6)) # чтобы создать генератор, нужно обрамить цикл for с выражением в круглые скобки
print(next(b)) # 1
print(next(b)) # 4
print(next(b)) # след элемент и тд.
```

**Также генератор можно обойти в цикле for, но только один раз. При том при второй попытке обойти генератор в цикле for ошибки, в отличии от функции next(), не будет. **

Точно так же это работает с некоторыми функциями, которые обходят элементы коллекции:
```python
b = (i**2 for i in range(1,6))
print(sum(b)) # 55
print(sum(b)) # 0 
# !!! Генератор можно обойти только один раз
```

Все элементы генератора не хранятся в памяти как единая коллекция, они формируются на лету при обходе в цикле или при помощи функции next(). Например, при применении next() будет сформирован следующий элемент, а предыдущий не сохранится в памяти. Эта и является смыслом использования генераторов.

```python 
a = list(range(10000000000)) # memory error
a = [i for i in range(10000000000) # тоже memory error]

c = (i for i in range(1000000000000))
for i in c:
	print(i) 
# а с генератором все работает,потому что он не хранит все элементы
```

```python
a = (i/2 for i in range(1,6))
list(a) 
# идентично с:
b = [i/2 for i in range(1, 6)]
```

**!!!** 
- К выражениям генератора нельзя применять фукнцию len(), так как генератор - не коллекция.
- К генераторам нельзя обратиться по индексам.

