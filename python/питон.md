# Варианты исполнения кода на python

1. Интерактивный вариант (консоль Python/Shell)
IDLE - и есть интерактивый вариант. В нем каждая инструкция исполняется моментально 

2. Файловый вариант (стандартный вариант)

# Знакомство с объектами в python

Программа - это набор инструкций, которая описывает компьютеру определенную последовательность действий. 

Программа состоит из инструкций. В свою очередь каждая инструкция создает или обрабатывает объекты. 

Встроенные типы объектов Python

![типы объектов](img/Типы объектов)

Функция type() позволяет узнать тип объекта

## Числа и операции над ними

### integer

Целое число - число, не содержащее дробной части.

Целые числа - все отрицательные числа, положительные и ноль. 

Функция для преобразования в тип integer - int()

### float

вещественные числа (числа с плавающей точкой) отличаются от целых наличием *дробной части*

Пример: 7.6, 8.0, -5.5

Целая часть отделяется от дробной знаком "точки". 

Функция float() - преобразует данные в вещественный тип. 

### Основные операции

![операции](img/операции)

Тонкости в операциях: 
- 2%7 = 2 (7\*0+2(!))
- любые операции с вещественным числом возвращают вещественное число 

![приоритеты](img/приоретиты)

Некоторые встроенные функции по работе с числами: 
![встроенне операции](img/встроенные)

abs - модуль. функция, которая отбрасывает знак
pow - возводит первое значение в степень второго
round - округление до целого числа ( round(число, до какого разряда)), можно задавать отриц значения, тем самым, например, округлив по десятки. при этом 3.5 -> 4

![разряды](img/разряды)

Все математические функции находятся в модуле math.

# Переменные в питоне. Оператор присваивания. 

Переменная - именованная область памяти, предназначенная для хранения значения. 
= - оператор присваивания. 

Чтобы создать переменную, нужно положить в нее значение. То есть они создаются в момент первого их присваения. 

![переменная](img/переменная)

Переменная должна начинаться с буквы или нижнего подчеркивания. Питон чувствителен к регистру букв. Также переменные не могут иметь зарезервированное слово в качестве идентификатора. 

Имена функций можно использовать в качестве идентификаторов, но возможность вызова этих функция потеряется. 

Создание переменной: 
а = 4
Есть список переменных и список объектов. 

- Создается объект целого типа со значением 4 
- Затем проверится есть ли переменная а. если нет, то она создается. 
- в переменной а сохранится ссылка на объект. 
Если мы присвоим переменной новое значение то:
- создастся объект вещественного типа со значением 5.4 
- Переменная а уже существует
- В переменную а сохранится новая ссылка, при том старая пропадет.

Динамическая типизация - переменные могут принимать значения любых типов. 

![присваивание](img/присваивание)

Массовое присваение: a=b=c=1
Множественные присваения: a, b = 2, 7 

# Ввод и вывод данных в питоне. 

Функция input() - считывает значения, которые пользователь вводит в консоль и возвращает его. 

Функция print() - выводит переданные ей значения. 

У нее есть параметр - sep (separate-разделять, separator - разделитеть). По умолчанию он равен пробелу. Чтобы изменить это поведение, нужно последним аргументом указать значение sep='' на произвольную строку, которая будет в качестве разделителя.

Также есть параметр end, который отвечает за то, что будет выводиться после всех значений, в конце. end='\n' - по умолчанию. Передав end новую строку, можно изменить его поведение. 

%s - специальный параметр, который указывается в строке, чтобы подставить туда значения из переменных. 
![процент](img/процент)

# Деление нацело и остаток от деления

Если любое число %10 - получим последнюю цифру

**любое число % (10 \*\* n) ** где n - сколько цифр хотим взят с конца. 

Если любое число //10 - уберем последнюю цифру 

**любое число // (10 \*\* n))** - где n - сколько цифр с конца нужно убрать 

# Функции trunc, floor, ceil

Все эти функции находятся в модуле math. 
trunc() - отсекает дробную часть. 
int() - тоже в процессе прообразования отсекает дробную часть. 
floor() - округление вниз. Наибольшее целое число, которое не превосходит нашего вещественного числа. 
ceil() - округление вверх. Наименьшее целое число, которое превосходит наше вещественное число. 
ceil() и floor() возвращают целые числа. 

# Логический тип bool. Операторы сравнения 

![сравнение](img/сравнение)

x%2==0 : True - четное, False - нечетное

x%n==0 : кратность, где x - число, которое кратно n. True - кратно, False - нет. 
x%n!=0 : некратность n. так же можно записать с помощью not x%4==0 

**and, or, not** 

bool() - функция преобразования в bool (любое непустое значение преобразуется в True)

# Строки и операции над ними

строки - ' ' или " "'
Многострочные строки - ''' ''' 


\n - перенос строки 
\t - табуляция 

'string' + 'second_string' - 'stringsecond_string' (конкатенация строк)
"a" * 5 - 'aaaaa' (умножение строк)

str() - преобразование в тип str

len() - длина строки, возвращает тип int 

с помощью **in** можно проверить есть ли какая то подстрока в нашей строке. 

Питон сравнивает строки посимвольно по коду букв. 'r'>'abc'
Числовое значение буквы можно получить с помощью функции ord().
Эти коды можно загуглить - ascii code table 

# None

None - неопределено

## Индексы и срезы 

Строка - **упорядоченная** коллекция символов. 
То есть каждый символ имеет свой индекс. 

Чтобы обратиться к каким либо символам строки через индекс, нужно указать его в []. 
строка[номер индекса]
'Hello'[1] -> e

string[len(string)-1] - чтобы получить последнюю букву. ИЛИ string[-1]

Срез - строка[С какого индекса брать:ДО какого брать]
В срезе можно не указывать один из индексов (правый или левый): 
string[4:] - с 4 до конца
string[:6] - с начала ДО 6
string[:] - вся строка 
Чтобы указать шаг нужно: string[::шаг]

Строка *неизменяемый* объект - то есть присвоить значение по индексу не получится. 
Но можно создать новую строку с помощью срезов и конкатенации. 

## Методы строк 

Метод - функция, которая связана с определенным типом объекта. То есть методы являются специфичными для каждого отдельного типа. 

Вызов метода: объект.метод(аргументы)

**Также есть цепочки вызовов методов: ** объект.метод().метод().метод()

s.upper() - метод, который ВОЗВРАЩАЕТ строку, где все ее буквы заглавные
s.lower() - метод, который ВОЗВРАЩАЕТ строку, где все ее буквы строчные

s = s.upper() - чтобы сохранить изменения

s.count('str', [начальный индекс, [конечный индекс]]) - подсчитывает сколько раз встретилась подстрока 'str' в строке s

s.find('str', [начальный индекс, [конечный индекс]]) - ищет индекс подстроки 'str'
s.rfind('str') - ищет индекс подстроки 'str' с конца

s.index('str') - возвращает индекс указанной подстроки
s.replace('o', '', количество замен) -  заменяет подстроку на другую (можно убрать пробелы в строке или удалить некоторые буквы)
s.isalpha() - возвращает True, если строка состоит целиком из букв
s.isdigit() - возвращает True, если строка состоит целиком из цифр
s.rjust(n, 'ОДИН символ заполнителя') - строка "прижимается" к правому краю и следовательно ПЕРЕД ним добавляется некоторое количество знаков заполнителя до того момента, когда длина строки будет равна n.  
s.ljust()

s.split('разделитель') - Разбивает строку по пробелам (по разделителям) и добавляет подстроки в список. 
![сплит](img/сплит)
связующий знак(разделитель).join(список строк)
![джоин](img/джоин )

s.strip() - удаляет знаки пробелов и служебные знаки(переносы строк)
s.rstrip() - удаляет справа знаки пробелов и служебные знаки(переносы строк)
s.lstrip() - удаляет слева знаки пробелов и служебные знаки(переносы строк)

# Форматирование строк

## метод format

Позиционное форматирование строк: 
print('text {0} text text {1} text text text {2}').format(value1, value2, value3) 
переменные в аргументе метода format нумеруются от 0 до n. Эти номера подставляются в строку в фигурных скобках. 

Именованное форматирование строк: 
a, b, c = 1, 2, 3
print('text {value1} text text {value2} text text text {value3}').format(value1=a, value2=b, value3=c) 

## f-строки

a, b = 1, 2
print(f'text {a.lower()} text text {b\*2} text {abs(-45)} text') - нужно поставить перед форматируемой строкой букву f и заключить названия переменных или инструкции в строке в фигурные скобки. 

# Списки и операции над ними

Список - упорядоченная коллекция элементов. Они позволяют хранить взаимосвязанные данные. 

[элемент, элемент, элемент] - список
Элементы могут быть любых типов.

len() - возвращает количество элементов в коллекции.

Сцепление списков: 
[a, b] + [c ,d] = [a, b, c, d]

Добваить элемент в конец: 
список = список + другой список

Добавить элемент в конец: 
список = другой список + список

Дублирование списков: 
[1, 2, 3] * 2 = [1, 2, 3, 1, 2, 3]

a = 'Hello'
list(a) -> ['H', 'e', 'l', 'l', 'o']

Проверка вхождения: 
значение in список -> True или False 

Если список состоит целиком из чисел, то вы можете:
max()
min()
sum()

sorted(список) - возвращает отсортированный список по возрастанию (по умолчанию)
Параметры: reverse=True - по убыванию 

Сравнение списков: 
Списки сравниваются поэлементно, то есть [3] > [2, 3, 1] -> True
список == список -> True , если в списке одинаковое количестко идентичных элементов. 

Среднее арифметическое списка: 
sum(список)/len(список)

**Распокование переменных **
a = [1, 2, 3]
b, c, d = a -> b = 1, c = 2, d = 3

## Списки: индексы и срезы

список[номер индексы] - обращение к элементу

Индексы от 0 до n, либо от -1 с конца до -n

Срез: список[ОТ какого индекса, ДО какого индекса]
При срезах можно указывать те значения индексов (напрмер очень большие), которых на самом деле нет. 

список[:до какого]
список[с какого:]
список[:]
список[n:n:g] , где g - шаг 

a = [ 1, 2, 3, 4, 5]
print(a[2:999:2])
-> [3, 5]
то есть первый элемент вне зависимости от шага - берется

список[::-1] - перевернуть список задом наперед. 

Список - **изменяемый объект** (в отличии от строк), поэтому по индексу можно поместить туда новое значение.

список[0, 2] = значение, значение - можно менять значения с помощью срезов. 
список[0, 3] = значение, значение

![прога](img/прогасписки)
![результат](img/спискирезультат)
Если с помощью среза, назначить как минимум трем элементам два значения, то те элементы, которым не хватило значений - удалятся ( в нашем случае третий).
То есть нескольким элементам, можно назначить только ОТ двух значений. 

С помощью функции del можно удалять значения по индексам. 
del список 
del список[i] 
del список[i:j:k] 

**Важная особенность списков:**
Если a = [1, 2, 3], а b = a, то переменные (которые хранят ссылки на объекты) будут ссылаться на один и тот же объект (**только в случае со списками**), и поэтому при изменении списка в одной переменной, мы изменяем этот же список и в другой. 
Чтобы избежать этой ситуации делать так:
a [1, 2, 3]
b = a[:]
тогда, мы сохраним в переменной b *копию* объекта, и списки в обоих переменных будут меняться независимо друг от друга. 

## Списки и их методы 

Методы в строках лишь *возвращают измененную строку*, но не меняют ее. В списках же дела обстоят иначе, методы меняют список. 

 append() добавляет *один* элемент с указанным значением в конец списка. 

Никогда не использовать методы, такие как append, с присвоением этой же переменной (как это было в строках): 
a = a.append(n)
иначе, потеряются все значения, будет None. 

 clear() - он очищает список.

 copy() - делает копию списка. (эквивалент список[:]) :
b = a.copy()

 count(значение) - подсчитывает сколько раз встечается определенное значение в списке.

 index(значение, начальный индекс, до какого индекса) - будет проходить по списку и искать индекс этого первого найденного значения. 

insert(индекс, объекст) - вставляет объект в нужное место, а все остальные значения сдвигаются вправо. 

pop() - удаляет значение с конца и возвращает его. 
pop(индекс) - удаляет и возвращает значение по индексу. 

remove(значение) - ищет значение в списке и удаляет одно лишь первое. (выводит исключение, если ничего не находит)
Для удаления всех значений лучше воспользоваться циклом while. 

reverse() - переворачивает список (эквивалент список[::-1])

sort() - сортировка по возрастанию
sort( reverse=True) - по убыванию 

## Вложенные списки

список = [[элемент, элемент], [элемент, элемент], [элемент, элемент]]
список\[индекс вложенного списка][индекс элемента во вложенном списке]

# Условный оператор if

if условие: 
	инструкции
else: 
	инструкции
инструкции

Для составных проверок - and, or, not
Отступ для отделения блоков - 4 пробела. 

Вложенность операторов if: 

if условие: 
	if условие:
		инструкции
	else:
		инструкции
else: 
	инструкции 

Множественный оператор if: 
if условие: 
	инструкции
elif условие:
	инструкции
...
else: 
	инструкции

# Цикл while

Конструкция while:
while условие:
	инструкции в цикле
	...
инструкции вне цикла

Пока *условие* будет верным, инструкции в теле цикла будут выполняться.

Инструкция **break** совершает принудительный выход из цикла. (и обходит блок else)

Инструкция **continue** принудительно завершает  итерацию и заново проверяет условие (перекидывает в начало цикла).  

Инструкция **else**: блок else будет выполняться после всех итерация цикла и только в том случае, когда цикл завершился "сам по себе" (без принудительного выхода).

while условие: 
	инструкции
else: 
	инструкции

# Функция range и итерируемые объекты

range() - помогает сформировать конечную арифметическую прогрессию. 
range - неизменяемый объект. 

range(До какого числа сформировать прогрессию)
range(С какого числа, ДО какого числа)  
range(С какого числа, ДО какого числа, шаг)

старт по умолчанию равен нулю, а шаг 1.

Функция range является итерируемым объектом. 
**Итерируемый объект** это объект, предоставляющий возможность поочередного прохода по своим элементам. 

Если функция range присвоена переменной, то по ней можно обращаться к значениям последовательности по индексам. Индексация начинается с нуля. (все это из за того, что это итерируемый объект)

range формирует пустую последовательность, если передать ей один аргумент - 0, или указать неправильный интервал.

Чтобы увидеть последовательность можно сформировать список из нее с помощью функции list().

Функция iter(итерируемый объект) - создает итератор.
С помощью функции next(итерируемый объект) можно вытаскивать из объекта следующие элементы. Итератор будет сам запоминать, где ( на каком индексе) он остановился. Если вызвать next при том, что элементы закончились, то он выдаст исключение. 
\# next() - функция
\# итерируемый\_объект.\_\_next\_\_() - метод

Цикл for сам вызывает этот метод next() и присваивает значение итерационной переменной. Так же он не выдает исключения, когда переменные закончились. 

# Цикл for

Цикл for в программировании - цикл с известным количеством повторений. 
Но в питоне это наиболее универскальный инструмент, с помощью которого так же можно поочередно обойти все элементы итерируемого объекта. 

for итерационная\_переменная in итерируемый объект : 
	тело цикла

Цикл for поочередно присваивает итерационной переменной все значения итерируемого объекта. 

Самые частые итерируемые объекты - range, строка, список и другие массивы. 

обход списков и строк: 
- по значениям for i in список/строка: 
- по индексам for i in range(len(список/строка))
Последний является более универсальным. 

Вложенные циклы. 
Формат: 
for переменная in объект:
	for переменная in объект:
		инструкции
		while условие: 
			инструкции
	инструкции 

# Множества, тип данных set 

Множество - неупорядоченная коллекция уникальных элементов. (отсутствуют повторяющиеся значения и индексы)

a = {  элемент, элемент, элемент }

a = { 1, 2, 3, 1, 2, 3} - > {1, 2, 3}

set() - преобразует объект в множество (исключает "дубли")
set('abcac') -> {'b', 'a', 'c'} (неупорядоченная коллекция!)

Чтобы создать пустое множество нужно использовать функцию set(). Выглдеть оно будет так    ' set() '. Нельзя создать пустое множество просто поставив {}, ибо в таком случае объект будет являться словарем. 

**Множество может содержать только НЕизменяемые объекты**
( числа, строки, кортежи )

list(set(список)) - убрать все дубли из списка

множество.add(значение) - изменяет сам объект, а не только возвращает его.

ЗАПРЕЩЕНО: a = a.add(элемент). Иначе, как и со списками, потеряем все значения

множество.update(итерируемый объект) - добавляет элементы итерируемого объекта в множество. 

Множество - **итерируемый объект**

множество.discard(значение) - удаляет элемент из множества, не выдает исключение, если элемента уже нет во множестве. 
множество.remove(значение) - удаляет элемент из множества, но будет исключение, если элемента не оказалось во множестве. 
множество.pop() - удаляет и возвращает случайный элемент. Если множество пусное, то будет ошибка
множество.clear() - очищает все элементы множества. То есть делает его пустым. 

## Операции над множествами

**Результаты операций над множествами МОЖНО присваивать этим же множествам**

len(множество) - длина

элемент in множество 

множество & множество2 - пересечение -> множество-пересечение

Чтобы присвоить результат пересечения множеств одному из множестве:
a &= c

множество1.intersection(множество2) - возвращает пересечение
множество1.intersection\_update(множество2) - присваивает множество пересечение в множество1.

множество1 | множество2 - объединение множеств
множество1.union(множество2) - тоже объединение
множество1 = множество1.union(множество2)

множество1 - множество2 - вычитание множеств

множество1 ^ множество2 - симметричная разность

Множества можно *сравнивать*: 
множество1 == множество2 - принадлежат ли все элементы одного мн-ва другому мн-ву и наоборот.

множество1 < множество2 - будет ли являться множество1 подмножеством множества2.
также >, >=, <= (подмножество или равно)

# Словари - dict. Операции и методы словаря. 

Словать - неупорядоченная коллекция произвольных объектов с доступом по ключу. (Ассоциативный массив)

словарь = { 
	ключ : значение,
	ключ : значение,      - **используется часто**
	ключ : значение
}

словарь[ключ]

Чаще всего ключ - строка (или любой другой тип данных, кроме изменяемых типов объекта (список)
Значением может являться любой тип данных)

dict(ключ=значение, ключ=значение) - создает словарь. При таком способе создания ключ обязательно должен быть строкой. 

Ключ можно писать без кавычек, функция сама сделает значения ключей строками.

Также словарь можно создать так: 
dict( [ [ключ, значение], [ключ, значение],[ключ, значение] ] )

словарь.fromkeys( ['a', 'b', 'c'] ) -> {''a" : None , ''b" : None, ''c" : None }
словарь.fromkeys( ['a', 'b', 'c'], значение по умолчанию) -> {''a" : значение , ''b" : значение, ''c" : значение }

переменная = {} - пустой словарь (**часто используется**)
переменная = dict() - пустой словарь

словарь {
	ключ : значение
	ключ : { ключ : значение, ключ : значение}
}

словарь\[ключ][ключ] 

словарь[новый\_ключ] = значение - добавление новой ассоциации
словарь[существующий\_ключ] = новое\_значение - изменение значения ассоциации

del словарь[ключ] - удаление ассоциации. (возвращает исключение, если такого ключа нет)

ключ (not) in словарь - проверка ключа

for key in словарь: 
	print(key, словар[key])
-> вывод ключа и значения (**цикл проходит словарь по ключам**)

Методы: 

словарь**.** ...

.clear() - очищает словарь

.get(ключ) - возвращает значение ключа. Отличие: если передать несуществующий ключ, то метод вернет значение None. 
.get(ключ, объект) - возвращает вместо None этот объект.

.setdefault(ключ) - вернет значение ключа, или если его нет - создает его и присвоит значение None. 
.setdefault(ключ, значение) - если ключа нет, то создает его и присвоит это значение (любой объект) 

.pop(ключ) - вернет значение ключа и удалит эту ассоциацию в нем. Вернет исключение, если ключа нет.

.popitem() - удаляет случайную ассоциацию и возвращает ее в виде словаря. Выдаст ошибку при попытке удалить что то из пустого словаря. 

.keys() - возвращает объект типа dict keys -> dict_keys([ключ, ключ, ключ])
цикл for по сути обходит значения по объекту типа dict_keys 

.values() - возвращает объект типа dict values -> dict_values([значение, значение, значение])
С помощью этого метода в цикле for можно пройтись по значениям. 

.items() - возвращает коллекцию в которой содержаться все пары - dic items -> dict_items([(ключ, значение), (ключ, значение), (ключ, значение)])
С помощью цикла for также можно обойти ассоциации. 

for key, value in словарь.items():
	print(key, value)

Это работает по принципу множественного присвоение 
a, b = [4, 7] -> a= 4, b = 7

